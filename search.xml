<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android 导入项目时，Gradle版本问题解决方案]]></title>
    <url>%2F2019%2F12%2F13%2FAndroid-%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%E6%97%B6%EF%BC%8CGradle%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[​ 在使用AndroidStudio导入项目时经常会出现各种问题，我在入职公司后导入公司的项目时就出现了与Gradle版本相关的问题，特此记录。 前言​ （这里都是废话，可以直接往下拉，看解决方案） ​ 刚入职公司，大佬丢给我公司的项目，让配好本地环境，然后把项目跑起来，哈哈，小意思，两个小时内都给你搞定，满心欢喜，终于可以见到真正的企业级的项目，毕竟在校期间都是写的一些小Demo，急切的想知道那种真正的可以上线的项目应该是怎样的，这种感觉就像在路边见到一个可爱的妹子，就想上前去问电话号码的那种急切的心情，呃呃，扯远了。 ​ 在导入项目之后，出现提示，本地没有项目依赖的资源，需要下载，好，点击确认下载，然后耐心等待。。。半个小时过去之后，终于开始重新构建项目，两眼放光，要开始了！。。。然后，构建失败，丢了几行红色错误提示给我，我擦，等了这么久就给我提示这个？！ ​ 错误提示说当前Gradle版本不一致也不兼容，行，我去看看网上都有什么解决方案。你问我以前难道没遇到过这种提示吗？当然遇到过，只不过以前都是Demo级别的，大不了把里面的代码文件复制出来一样跑，现在公司的项目可不能像以前那样干了。方案一和方案二是网上推荐的方法，方案三和方案四是我自己的歪门邪道，不过亲测好用（特别推荐解决方案四，方便、快捷）。 解决方案一​ 修改项目的根目录下的build.gradle文件里的dependencies-&gt;classpath里的Gradle版本和Gradle插件版本，改成本地的Gradle版本。修改教程：https://blog.csdn.net/qq_26287435/article/details/88532190。 ​ 但是如果是公司的项目的话，东西比较多，可能改了这一个地方就会报一堆奇奇怪怪错误，然后再去解决这一堆奇奇怪怪的错误，心累，不建议这么干，但是可以先进行尝试，万一成功了呢，梦想还是要有的。 解决方案二​ 根据项目里的Gradle版本去网上下载相应版本，并进行引用。下载网址：https://services.gradle.org/distributions/。教程：https://blog.csdn.net/qq1607613241/article/details/79013255。 ​ 这个方法我用了，但是我在构建项目的时候，又会提示当前IDE版本最低支持XXX版本，你的Gradle版本太低，构建失败。因为公司的项目使用的Gradle版本太低，而我使用AndroidStudio的版本是最新的，没办法，只能另辟蹊径。 解决方案三​ 简单粗暴，把装好的AndroidStudio卸载，下载安装比较低版本的AndroidStudio（如果AndroidStudio里的Gradle和项目使用的Gradle版本一致就更好了，），然后再导入项目，并构建项目成功后，再升级AndroidStudio的版本至最新版本。至此，完成。 ​ 这个方法简单粗暴，但是麻烦，下面介绍一个更好的方法。 解决方案四​ 新建一个AndroidStudio的项目，然后把新建的项目里的（.gradle）和（.idea）以及（gradle）文件复制进要导入的项目的根目录里，然后再通过AndroidStudio导入项目，等待构建完成。 ​ 这个办法是我脑子一个激灵想到的，因为是Gradle构建的时候出问题，那我就用别的项目的gradle文件，看看能不能构建成功，没想到竟然成功。如果你问我为什么这样可以构建成功，我也没办法给出一个明确的答案，希望以后我在技术提高之后能再回过头仔细研究这个问题。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 回调机制解析]]></title>
    <url>%2F2019%2F05%2F29%2FJava-%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[调用概述​ 在讲回调之前需要对调用方式有个概念。函数调用方式分为两种，分别是同步调用和异步调用。 ​ 同步调用是最基本的调用方式：类A的方法a()调用类B的方法b()，然后一直等待b()方法执行完毕后，a()方法再继续往下执行。这种调用方式是顺序执行的，适用于需要顺序执行的情况。 ​ 异步调用为了并行执行程序而出现的调用方式：类A的方法a()通过新起线程的方式调用类B的方法b()，然后代码接着直接往下执行，与b()方法并行执行。这种方式适用于代码需要同时执行或b()方法执行时间过长，防止阻塞的情况。 ​ 回调和一般调用的区别在于：在被调用者类B的方法b()执行完毕后，再去调用类A的方法c()，进行类似于一个通知的操作。 回调概述​ 回调：类A的a()方法调用类B的b()方法，当类B的b()方法的执行完成后又去调用类A里的c()方法，进行通知。是一种双向的调用方式，类似于消息或事件的机制。 ​ 一般情况下，回调分两种，分别是同步回调和异步回调，主要区别在于是否新建线程执行。 同步回调​ 同步，就说明了这是是一种顺序执行的方式，需要等待执行结果出来后，再继续执行下一步。下面用一个计算器的例子来展示说明。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class CallBack&#123; public static void main(String []args) &#123; int a = 10452; int b = 423; //实例化计算器Calculator类 Calculator calculator = new Calculator(a,b); //调用计算器calculator的计算函数 calculator.calculation(); //控制台输出 System.out.println("/========================/"); &#125;&#125;//计算器类class Calculator&#123; private int a,b; public Calculator(int a, int b) &#123; this.a = a; this.b = b; &#125; public void calculation() &#123; new Logic().calculationLogic(a, b, Calculator.this); &#125; //用于接收回调结果，并打印输出 public void calculationResult(int a, int b, int result) &#123; //控制台输出计算 System.out.println(a + " + " + b + " = " + result); &#125;&#125;//计算的具体逻辑类class Logic&#123; //计算的具体逻辑(计算方式) public void calculationLogic(int a, int b, Calculator calculator) &#123; int result = a + b; //让线程等待5秒，模拟需要执行的时间 try &#123; Thread.sleep(5 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //利用传进来的对象,回调计算结果. calculator.calculationResult(a, b, result); &#125;&#125; 123运行结果： 10452 + 423 = 10875 /========================/ 异步回调​ 异步，就说明了这是是一种并行执行的方式，不需要等待执行结果出来后再继续执行，而是可以同步进行，执行结果出来后，再回调进行通知。下面还是用一个计算器的例子来展示说明。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class CallBack&#123; public static void main(String []args) &#123; int a = 10452; int b = 423; //实例化计算器Calculator类 Calculator calculator = new Calculator(a,b); //调用计算器calculator的计算函数 calculator.calculation(); //控制台输出 System.out.println("/========================/"); &#125;&#125;//计算的具体逻辑类class Logic&#123; //计算的具体逻辑(计算方式) public void calculationLogic(int a, int b, Calculator calculator) &#123; int result = a + b; //让线程等待5秒 try &#123; Thread.sleep(5 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //利用传进来的对象,回调计算结果. calculator.calculationResult(a, b, result); &#125;&#125;//计算器类class Calculator&#123; private int a,b; public Calculator(int a, int b) &#123; this.a = a; this.b = b; &#125; public void calculation() &#123; //开启另一个子线程 new Thread(new Runnable() &#123; public void run() &#123; new Logic().calculationLogic(a, b, Calculator.this); &#125; &#125;).start(); &#125; //用于接收回调结果，并打印输出 public void calculationResult(int a, int b, int result) &#123; //控制台输出计算结果 System.out.println(a + " + " + b + " = " + result); &#125;&#125; 123运行结果： /========================/ 10452 + 423 = 10875 ​ 你会发现，输出”/====/”明明是放在代码的最后，结果却先执行输出了，这是因为开了另一个线程，而异步回调和同步回调最大的区别就是异步回调里新建了一个线程。异步回调常见于请求服务器数据，当取到数据时,会进行回调。 扩展知识​ 另一种回调方式，主要是为解决当回调的逻辑不明确时，该如何处理回调逻辑。解决方法：传入实现的接口对象，在对象里实现具体的回调方法逻辑。 ​ 下面的还是用计算器的例子，比如不一定用计算器进行加法运算，也有可能进行乘法运算，下面是同步回调。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class CallBack&#123; public static void main(String []args) &#123; int a = 10452; int b = 423; //实例化计算器Calculator类,并传一个匿名的Logic对象，重写calculationLogic()方法 Calculator calculator = new Calculator(new Logic() &#123; //重写计算逻辑函数calculationLogic,实现具体计算逻辑 public void calculationLogic(int a, int b)&#123; int result = a * b; System.out.println(a + " * " + b + " = " + result); &#125; &#125;); //调用计算器calculator的计算函数calculation calculator.calculation(a, b); //控制台输出 System.out.println("/========================/"); &#125;&#125;//计算的逻辑回调接口interface Logic&#123; //计算的逻辑回调函数 public void calculationLogic(int a, int b);&#125;//计算器类class Calculator&#123; private Logic logic; public Calculator(Logic logic) &#123; this.logic = logic; &#125; public void calculation(int a, int b) &#123; //调用logic对象里的计算逻辑函数calculationLogic logic.calculationLogic(a, b); &#125;&#125; 123运行结果： 10452 * 423 = 4421196 /========================/ ​ 异步回调也同理，在Calculator类的calculation()函数里新建一个线程就行了，这里就不举例了。 ​ 既然了解了这种回调方法，那么继续深入这种方式具体能在什么现实的场景下使用呢？现在我提一个需求：给定一个数字，再通过网络请求获取一个数字，然后把这两个数字进行加减或乘除（即实现逻辑不明确），同时不能阻塞线程。没错，通过上面传入实现接口对象的异步回调方式去实现。下面是代码展示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Main &#123; public static void main(String[] args) &#123; int a = 3; //实例化计算器Calculator类,并传一个匿名的Logic对象，重写calculationLogic()方法 new Calculator(a, new Calculator.Logic() &#123; //重写计算逻辑函数calculationLogic,实现具体计算逻辑 public void calculationLogic(int a, int b)&#123; int result = a * b; System.out.println(a + " * " + b + " = " + result); &#125; &#125;).start(); //控制台输出 System.out.println("/========================/"); &#125;&#125;//计算器类class Calculator&#123; private int a; private Logic logic; public Calculator(int a, Logic logic) &#123; this.a = a; this.logic = logic; &#125; public Calculator start() &#123; //开启另一个线程 new Thread(new Runnable() &#123; public void run() &#123; //让线程等待5秒,模拟请求网络的耗时 try &#123; Thread.sleep(5 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; int b = 10;//模拟请求到的数据 logic.calculationLogic(a, b); &#125; &#125;).start(); return this;//返回当前对象 &#125; //计算的逻辑回调接口 interface Logic &#123; //计算的逻辑回调函数 public void calculationLogic(int a, int b); &#125;&#125; 123运行结果： /========================/3 * 10 = 30]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
