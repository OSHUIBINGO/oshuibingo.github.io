<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Flutter 学习笔记之Dart语言]]></title>
    <url>%2F2019%2F12%2F18%2FFlutter-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BDart%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Android 验证码输入框的实现]]></title>
    <url>%2F2019%2F12%2F15%2FAndroid-%E9%AA%8C%E8%AF%81%E7%A0%81%E8%BE%93%E5%85%A5%E6%A1%86%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[​ 接到公司的一些需求，其中有一个需求挺有意思的，实现一个验证码输入界面，想了一下，感觉还挺简单的，一组TextView和EditText就可以实现了，但是在实现过程中遇到了很多坑，特此记录。 界面效果​ 实现的界面大概长成这样： ​ ​ 分析：一个验证码输入框+确定按钮。要注意的是，当验证码没有输入完成的时候，确定按钮是灰色且不可点击；当验证码输入完成后，改变背景颜色且可点击。 具体实现第一步：自定义EditText控件​ 继承重写EditText控件的onSelectionChanged()方法和onTouchEvent()方法。onSelectionChanged()方法是用来监听光标的移动事件，在这个方法里面需要设置光标始终在最后，防止用户控制光标左右移动；onTouchEvent()方法主要对点击事件的处理，我们在里面对双击的事件进行拦截，防止用户双击之后出现出现复制粘贴的选项。 1234567891011121314151617181920212223242526272829303132333435363738394041public class VerifyCodeEditText extends AppCompatEditText &#123; private long lastTime = 0; public VerifyCodeEditText(Context context) &#123; super(context); &#125; public VerifyCodeEditText(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public VerifyCodeEditText(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override protected void onSelectionChanged(int selStart, int selEnd) &#123; super.onSelectionChanged(selStart, selEnd); //设置光标始终在最后 this.setSelection(this.getText().length()); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; //拦截双击事件，防止连续双击出现复制粘贴的选项 switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: //根据当前点击和上一次点击的时间间隔判断是否是双击 long currentTime = System.currentTimeMillis(); if (currentTime - lastTime &lt; 500) &#123; lastTime = currentTime; return true; &#125; else &#123; lastTime = currentTime; &#125; break; &#125; return super.onTouchEvent(event); &#125;&#125; 第二步：自定义验证码输入框控件​ 在xml里绘制布局，新建一个类代码里继承RelativeLayout，重写构造方法，在构造方法里面加入我们需要的东西。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="48dp" android:gravity="center" android:orientation="horizontal"&gt; &lt;TextView android:id="@+id/tv_0" style="@style/VerifyCodeView" /&gt; &lt;View android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" /&gt; &lt;TextView android:id="@+id/tv_1" style="@style/VerifyCodeView" /&gt; &lt;View android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" /&gt; &lt;TextView android:id="@+id/tv_2" style="@style/VerifyCodeView" /&gt; &lt;View android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" /&gt; &lt;TextView android:id="@+id/tv_3" style="@style/VerifyCodeView" /&gt; &lt;View android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" /&gt; &lt;TextView android:id="@+id/tv_4" style="@style/VerifyCodeView" /&gt; &lt;View android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" /&gt; &lt;TextView android:id="@+id/tv_5" style="@style/VerifyCodeView" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="48dp" android:gravity="center" android:orientation="horizontal"&gt; &lt;View android:id="@+id/view_0" android:layout_width="41dp" android:layout_height="2dp" android:layout_gravity="bottom" android:background="@color/colorPrimary" /&gt; &lt;View android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" /&gt; &lt;View android:id="@+id/view_1" android:layout_width="41dp" android:layout_height="2dp" android:layout_gravity="bottom" android:background="@color/colorPrimary" /&gt; &lt;View android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" /&gt; &lt;View android:id="@+id/view_2" android:layout_width="41dp" android:layout_height="2dp" android:layout_gravity="bottom" android:background="@color/colorPrimary" /&gt; &lt;View android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" /&gt; &lt;View android:id="@+id/view_3" android:layout_width="41dp" android:layout_height="2dp" android:layout_gravity="bottom" android:background="@color/colorPrimary" /&gt; &lt;View android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" /&gt; &lt;View android:id="@+id/view_4" android:layout_width="41dp" android:layout_height="2dp" android:layout_gravity="bottom" android:background="@color/colorPrimary" /&gt; &lt;View android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" /&gt; &lt;View android:id="@+id/view_5" android:layout_width="41dp" android:layout_height="2dp" android:layout_gravity="bottom" android:background="@color/colorPrimary" /&gt; &lt;/LinearLayout&gt; &lt;com.verifycodedemo.VerifyCodeEditText android:id="@+id/verify_code_input_edit_text" android:layout_width="match_parent" android:layout_height="48dp" android:background="@android:color/transparent" android:textColor="@android:color/transparent" android:longClickable="false" android:maxLength="6" android:inputType="number" /&gt;&lt;/RelativeLayout&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120public class VerifyCodeInputView extends RelativeLayout &#123; private EditText editText; private TextView[] textViews; private View[] views; private final int MAX = 6; private String inputContent; private InputContentListener inputContentListener; public VerifyCodeInputView(Context context) &#123; this(context, null); &#125; public VerifyCodeInputView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public VerifyCodeInputView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); //加载布局文件 View view= View.inflate(context, R.layout.view_verify_code_input, this); //初始化布局ID textViews = new TextView[MAX]; textViews[0] = view.findViewById(R.id.tv_0); textViews[1] = view.findViewById(R.id.tv_1); textViews[2] = view.findViewById(R.id.tv_2); textViews[3] = view.findViewById(R.id.tv_3); textViews[4] = view.findViewById(R.id.tv_4); textViews[5] = view.findViewById(R.id.tv_5); views = new View[MAX]; views[0] = view.findViewById(R.id.view_0); views[1] = view.findViewById(R.id.view_1); views[2] = view.findViewById(R.id.view_2); views[3] = view.findViewById(R.id.view_3); views[4] = view.findViewById(R.id.view_4); views[5] = view.findViewById(R.id.view_5); editText = view.findViewById(R.id.verify_code_input_edit_text); //隐藏光标 editText.setCursorVisible(false); //监听输入的状态 editText.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) &#123; &#125; @Override public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) &#123; &#125; @Override public void afterTextChanged(Editable editable) &#123; //获取输入框内容 inputContent = editText.getText().toString(); if (inputContentListener != null) &#123; //如果输入长度等于字符长度最大值 if (inputContent.length() == MAX) &#123; //回调输入完成监听 inputContentListener.inputComplete(); &#125; else &#123; //否则回调输入内容改变监听 inputContentListener.contentChange(); &#125; &#125; //每次输入框内容改变后，把输入框的内容循环赋值给TextView,并改变下划线颜色 for (int i = 0; i &lt; MAX; i++) &#123; //把输入框的内容循环赋值给TextView if (i &lt; inputContent.length()) &#123; textViews[i].setText(String.valueOf(inputContent.charAt(i))); &#125; else &#123; textViews[i].setText(""); &#125; //并改变下划线颜色 if (i == inputContent.length()-1)&#123; views[i].setBackgroundColor(getContext().getColor(R.color.colorAccent)); &#125;else &#123; views[i].setBackgroundColor(getContext().getColor(R.color.colorPrimary)); &#125; &#125; &#125; &#125;); &#125; //获取内容 public String getEditContent() &#123; return inputContent; &#125; //内容清空 public void setClear() &#123; editText.getText().clear(); &#125; public void setInputContentListener(InputContentListener inputContentListener) &#123; this.inputContentListener = inputContentListener; &#125; public interface InputContentListener &#123; //输入框完成回调 void inputComplete(); //输入框改变回调 void contentChange(); &#125;&#125; 第三步：使用​ 前置工作都已经完成，下面进行具体的实现。 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_margin="30dp" tools:context=".MainActivity"&gt; &lt;com.verifycodedemo.VerifyCodeInputView android:id="@+id/verify_code_view" android:layout_width="match_parent" android:layout_height="wrap_content" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" app:layout_constraintBottom_toBottomOf="parent" /&gt; &lt;Button android:id="@+id/bu_verify" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="确认" android:textColor="@color/white" android:background="@drawable/input_verify_code_button1" android:paddingBottom="10dp" android:paddingTop="10dp" android:paddingRight="135dp" android:paddingLeft="135dp" android:layout_marginTop="30dp" app:layout_constraintRight_toRightOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintTop_toBottomOf="@+id/verify_code_view" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MainActivity extends AppCompatActivity &#123; Button verifyButton; VerifyCodeInputView verifyCodeInputView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); verifyButton = findViewById(R.id.bu_verify); verifyButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //清空内容 verifyCodeInputView.setClear(); Toast.makeText(getApplicationContext(),"清空内容", Toast.LENGTH_SHORT).show(); &#125; &#125;); verifyCodeInputView = findViewById(R.id.verify_code_view); verifyCodeInputView.setInputContentListener(new VerifyCodeInputView.InputContentListener() &#123; @Override public void inputComplete() &#123; //确认按钮变黄 verifyButton.setBackgroundResource(R.drawable.input_verify_code_button2); //6位验证码输入完成监听 Toast.makeText(getApplicationContext(), "6位验证码输入完成：" + verifyCodeInputView.getEditContent(), Toast.LENGTH_SHORT).show(); &#125; @Override public void contentChange() &#123; //确认按钮变灰 verifyButton.setBackgroundResource(R.drawable.input_verify_code_button1); //验证码内容改变监听 Toast.makeText(getApplicationContext(),"验证码内容改变" + verifyCodeInputView.getEditContent(),Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125; 结语​ 上面没有贴上具体的样式，Demo的GitHub地址：https://github.com/OSHUIBINGO/VerifyCodeInputViewDemo ​ 这么做是完成了公司的需求，但是复用性不高，因为引用了很多的xml还有样式之类的，不方便复用，接下来，就提高复用性这方面做出改进，之后也许会出2.0版本的验证码输入框。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 导入项目时，Gradle版本问题解决方案]]></title>
    <url>%2F2019%2F12%2F13%2FAndroid-%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%E6%97%B6%EF%BC%8CGradle%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[​ 在使用AndroidStudio导入项目时经常会出现各种问题，我在入职公司后导入公司的项目时就出现了与Gradle版本相关的问题，特此记录。 前言​ （这里都是废话，可以直接往下拉，看解决方案） ​ 刚入职公司，大佬丢给我公司的项目，让配好本地环境，然后把项目跑起来，哈哈，小意思，两个小时内都给你搞定，满心欢喜，终于可以见到真正的企业级的项目，毕竟在校期间都是写的一些小Demo，急切的想知道那种真正的可以上线的项目应该是怎样的，这种感觉就像在路边见到一个可爱的妹子，就想上前去问电话号码的那种急切的心情，呃呃，扯远了。 ​ 在导入项目之后，出现提示，本地没有项目依赖的资源，需要下载，好，点击确认下载，然后耐心等待。。。半个小时过去之后，终于开始重新构建项目，两眼放光，要开始了！。。。然后，构建失败，丢了几行红色错误提示给我，我擦，等了这么久就给我提示这个？！ ​ 错误提示说当前Gradle版本不一致也不兼容，行，我去看看网上都有什么解决方案。你问我以前难道没遇到过这种提示吗？当然遇到过，只不过以前都是Demo级别的，大不了把里面的代码文件复制出来一样跑，现在公司的项目可不能像以前那样干了。方案一和方案二是网上推荐的方法，方案三和方案四是我自己的歪门邪道，不过亲测好用（特别推荐解决方案四，方便、快捷）。 解决方案一​ 修改项目的根目录下的build.gradle文件里的dependencies-&gt;classpath里的Gradle版本和Gradle插件版本，改成本地的Gradle版本。修改教程：https://blog.csdn.net/qq_26287435/article/details/88532190。 ​ 但是如果是公司的项目的话，东西比较多，可能改了这一个地方就会报一堆奇奇怪怪错误，然后再去解决这一堆奇奇怪怪的错误，心累，不建议这么干，但是可以先进行尝试，万一成功了呢，梦想还是要有的。 解决方案二​ 根据项目里的Gradle版本去网上下载相应版本，并进行引用。下载网址：https://services.gradle.org/distributions/。教程：https://blog.csdn.net/qq1607613241/article/details/79013255。 ​ 这个方法我用了，但是我在构建项目的时候，又会提示当前IDE版本最低支持XXX版本，你的Gradle版本太低，构建失败。因为公司的项目使用的Gradle版本太低，而我使用AndroidStudio的版本是最新的，没办法，只能另辟蹊径。 解决方案三​ 简单粗暴，把装好的AndroidStudio卸载，下载安装比较低版本的AndroidStudio（如果AndroidStudio里的Gradle和项目使用的Gradle版本一致就更好了，），然后再导入项目，并构建项目成功后，再升级AndroidStudio的版本至最新版本。至此，完成。 ​ 这个方法简单粗暴，但是麻烦，下面介绍一个更好的方法。 解决方案四​ 新建一个AndroidStudio的项目，然后把新建的项目里的（.gradle）和（.idea）以及（gradle）文件复制进要导入的项目的根目录里，然后再通过AndroidStudio导入项目，等待构建完成。 ​ 这个办法是我脑子一个激灵想到的，因为是Gradle构建的时候出问题，那我就用别的项目的gradle文件，看看能不能构建成功，没想到竟然成功。如果你问我为什么这样可以构建成功，我也没办法给出一个明确的答案，希望以后我在技术提高之后能再回过头仔细研究这个问题。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 回调机制解析]]></title>
    <url>%2F2019%2F05%2F29%2FJava-%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[调用概述​ 在讲回调之前需要对调用方式有个概念。函数调用方式分为两种，分别是同步调用和异步调用。 ​ 同步调用是最基本的调用方式：类A的方法a()调用类B的方法b()，然后一直等待b()方法执行完毕后，a()方法再继续往下执行。这种调用方式是顺序执行的，适用于需要顺序执行的情况。 ​ 异步调用为了并行执行程序而出现的调用方式：类A的方法a()通过新起线程的方式调用类B的方法b()，然后代码接着直接往下执行，与b()方法并行执行。这种方式适用于代码需要同时执行或b()方法执行时间过长，防止阻塞的情况。 ​ 回调和一般调用的区别在于：在被调用者类B的方法b()执行完毕后，再去调用类A的方法c()，进行类似于一个通知的操作。 回调概述​ 回调：类A的a()方法调用类B的b()方法，当类B的b()方法的执行完成后又去调用类A里的c()方法，进行通知。是一种双向的调用方式，类似于消息或事件的机制。 ​ 一般情况下，回调分两种，分别是同步回调和异步回调，主要区别在于是否新建线程执行。 同步回调​ 同步，就说明了这是是一种顺序执行的方式，需要等待执行结果出来后，再继续执行下一步。下面用一个计算器的例子来展示说明。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class CallBack&#123; public static void main(String []args) &#123; int a = 10452; int b = 423; //实例化计算器Calculator类 Calculator calculator = new Calculator(a,b); //调用计算器calculator的计算函数 calculator.calculation(); //控制台输出 System.out.println("/========================/"); &#125;&#125;//计算器类class Calculator&#123; private int a,b; public Calculator(int a, int b) &#123; this.a = a; this.b = b; &#125; public void calculation() &#123; new Logic().calculationLogic(a, b, Calculator.this); &#125; //用于接收回调结果，并打印输出 public void calculationResult(int a, int b, int result) &#123; //控制台输出计算 System.out.println(a + " + " + b + " = " + result); &#125;&#125;//计算的具体逻辑类class Logic&#123; //计算的具体逻辑(计算方式) public void calculationLogic(int a, int b, Calculator calculator) &#123; int result = a + b; //让线程等待5秒，模拟需要执行的时间 try &#123; Thread.sleep(5 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //利用传进来的对象,回调计算结果. calculator.calculationResult(a, b, result); &#125;&#125; 123运行结果： 10452 + 423 = 10875 /========================/ 异步回调​ 异步，就说明了这是是一种并行执行的方式，不需要等待执行结果出来后再继续执行，而是可以同步进行，执行结果出来后，再回调进行通知。下面还是用一个计算器的例子来展示说明。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class CallBack&#123; public static void main(String []args) &#123; int a = 10452; int b = 423; //实例化计算器Calculator类 Calculator calculator = new Calculator(a,b); //调用计算器calculator的计算函数 calculator.calculation(); //控制台输出 System.out.println("/========================/"); &#125;&#125;//计算的具体逻辑类class Logic&#123; //计算的具体逻辑(计算方式) public void calculationLogic(int a, int b, Calculator calculator) &#123; int result = a + b; //让线程等待5秒 try &#123; Thread.sleep(5 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //利用传进来的对象,回调计算结果. calculator.calculationResult(a, b, result); &#125;&#125;//计算器类class Calculator&#123; private int a,b; public Calculator(int a, int b) &#123; this.a = a; this.b = b; &#125; public void calculation() &#123; //开启另一个子线程 new Thread(new Runnable() &#123; public void run() &#123; new Logic().calculationLogic(a, b, Calculator.this); &#125; &#125;).start(); &#125; //用于接收回调结果，并打印输出 public void calculationResult(int a, int b, int result) &#123; //控制台输出计算结果 System.out.println(a + " + " + b + " = " + result); &#125;&#125; 123运行结果： /========================/ 10452 + 423 = 10875 ​ 你会发现，输出”/====/”明明是放在代码的最后，结果却先执行输出了，这是因为开了另一个线程，而异步回调和同步回调最大的区别就是异步回调里新建了一个线程。异步回调常见于请求服务器数据，当取到数据时,会进行回调。 扩展知识​ 另一种回调方式，主要是为解决当回调的逻辑不明确时，该如何处理回调逻辑。解决方法：传入实现的接口对象，在对象里实现具体的回调方法逻辑。 ​ 下面的还是用计算器的例子，比如不一定用计算器进行加法运算，也有可能进行乘法运算，下面是同步回调。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class CallBack&#123; public static void main(String []args) &#123; int a = 10452; int b = 423; //实例化计算器Calculator类,并传一个匿名的Logic对象，重写calculationLogic()方法 Calculator calculator = new Calculator(new Logic() &#123; //重写计算逻辑函数calculationLogic,实现具体计算逻辑 public void calculationLogic(int a, int b)&#123; int result = a * b; System.out.println(a + " * " + b + " = " + result); &#125; &#125;); //调用计算器calculator的计算函数calculation calculator.calculation(a, b); //控制台输出 System.out.println("/========================/"); &#125;&#125;//计算的逻辑回调接口interface Logic&#123; //计算的逻辑回调函数 public void calculationLogic(int a, int b);&#125;//计算器类class Calculator&#123; private Logic logic; public Calculator(Logic logic) &#123; this.logic = logic; &#125; public void calculation(int a, int b) &#123; //调用logic对象里的计算逻辑函数calculationLogic logic.calculationLogic(a, b); &#125;&#125; 123运行结果： 10452 * 423 = 4421196 /========================/ ​ 异步回调也同理，在Calculator类的calculation()函数里新建一个线程就行了，这里就不举例了。 ​ 既然了解了这种回调方法，那么继续深入这种方式具体能在什么现实的场景下使用呢？现在我提一个需求：给定一个数字，再通过网络请求获取一个数字，然后把这两个数字进行加减或乘除（即实现逻辑不明确），同时不能阻塞线程。没错，通过上面传入实现接口对象的异步回调方式去实现。下面是代码展示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Main &#123; public static void main(String[] args) &#123; int a = 3; //实例化计算器Calculator类,并传一个匿名的Logic对象，重写calculationLogic()方法 new Calculator(a, new Calculator.Logic() &#123; //重写计算逻辑函数calculationLogic,实现具体计算逻辑 public void calculationLogic(int a, int b)&#123; int result = a * b; System.out.println(a + " * " + b + " = " + result); &#125; &#125;).start(); //控制台输出 System.out.println("/========================/"); &#125;&#125;//计算器类class Calculator&#123; private int a; private Logic logic; public Calculator(int a, Logic logic) &#123; this.a = a; this.logic = logic; &#125; public Calculator start() &#123; //开启另一个线程 new Thread(new Runnable() &#123; public void run() &#123; //让线程等待5秒,模拟请求网络的耗时 try &#123; Thread.sleep(5 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; int b = 10;//模拟请求到的数据 logic.calculationLogic(a, b); &#125; &#125;).start(); return this;//返回当前对象 &#125; //计算的逻辑回调接口 interface Logic &#123; //计算的逻辑回调函数 public void calculationLogic(int a, int b); &#125;&#125; 123运行结果： /========================/3 * 10 = 30]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
